---
title: "Tech Review Review"
output: html_notebook
---

1: Business Understanding:

1.1: Business Objectives
  -Provide summary statistics for tech reviewers.
  -Provide leveled list of which tech reviewers reviews the highest quantity, and how harshly.
  

1.2: Assess Situation
  -.csv file with multiple tabs supplied.
  -No computational resources provided.
  -No paid time for project provided. 
  -Minimal requirements/deliverables provided for the project.
  -Possibly results in metric rankings that would bias evaluation of analysts or tech reviewers. Primary risk.


1.3: Data Mining Goals
  Success here will look like an even evaluation of each tech reviewer with appropriate weighting
  applied to distinguish method evaluations, validations, and routine testing to properly review tech
  reviewer productivity. Weighting will also be applied to the "C1 - C7" encoded variables which encode
  for quality errors. 
  

2: Data Understanding: 

  2.1: Describe Data
  Dates are imported appropriately, everything else is a character class. Drop all columns including and after comments.
  Hans BY FAR makes up the majority of the data set. More than double. Followed by Dolly and Vir. Chris's data is completely missing,
  and will be removed from analysis.
  
  Kelly has reviewed an unusually high number of projects given her start date. Order goes Hans <- Vir <- Dolly <- Dennis <- Kelly.
  Differing number of variables in each sheet, and need to be normalized.
 
 
  2.2: Explore Data
  
  We really need to find a primary key or make one, or find some way to join tables.
  Lets also plan to drop NA values that do not have analyst name observations attached to.
  
  Hans reviews Lauren's projects the most.
  Vir reviewed Katie's projects the most. 
  Kim reviews Hillary's projects the most.
  Dolly reviews David M's projects the most, but very evenly reviews across the entire department.
  Clester reviews Katie's projects the most. 
  Michael reviews Alexander's projects the most. Possibly drop Michael from data set as not applicable to analytical services.
  Sarah reviews Hillary's projects the most.
  Dennis reviewed Yesenia's projects the most, and also Caterine's. But now Edmond is #1 of people still at Cambrex.
  Kelly reviews Doug's projects the most of analytical services.
  
#tr.chris is completely empty
#tr.jeff having trouble importing
```{r}
#Import Data
library(tidyverse)
library(moderndive)
library(readxl)

filepath <- "C:/Users/mastl/Desktop/Grad_School/2021_tr.xlsx"

tr.df <- excel_sheets("C:/Users/mastl/Desktop/Grad_School/2021_tr.xlsx")


#tr.jeff <- read_xlsx(filepath, sheet = "Jeff B", skip = 8)
tr.hans <- read_xlsx(filepath, sheet = "Hans H", skip = 8)
tr.vir <- read_xlsx(filepath, sheet = "Vir P", skip = 8)
tr.kim <- read_xlsx(filepath, sheet = "Kim J", skip = 8)
tr.dolly <- read_xlsx(filepath, sheet = "Dolly W", skip = 8)
tr.clester <- read_xlsx(filepath, sheet = "Clester O", skip = 8)
tr.michael <- read_xlsx(filepath, sheet = "Michael K", skip = 8)
tr.chris <- read_xlsx(filepath, sheet = "Chris S", skip = 8)
tr.sarah <- read_xlsx(filepath, sheet = "Sarah C", skip = 8)
tr.dennis <- read_xlsx(filepath, sheet = "Dennis W", skip = 8)
tr.kelly <- read_xlsx(filepath, sheet = "Kelly L", skip = 8)

tr.reviewers <- list("hans" = tr.hans, 
                     "vir" =tr.vir, 
                     "kim" = tr.kim, 
                     "dolly" = tr.dolly, 
                     "clester" = tr.clester,
                     "michael" = tr.michael,
                     "sarah" = tr.sarah, 
                     "dennis" = tr.dennis, 
                     "kelly" = tr.kelly)

for(i in 1:9) {
n <-  names(tr.reviewers[i])
s <-  summary(tr.reviewers[[i]])
d <-  dim(tr.reviewers[[i]])

print(n)
print(s)
print(d)
}
```


#Summarizes how many times a tech reviewer has reviewed each analyst.

```{R}
for(i in 1:9) {
  n <- names(tr.reviewers[i])
  a <- table(tr.reviewers[[i]]$Analyst)
  a.df <- as.data.frame(a)
  a.df <- a.df %>% 
    arrange(desc(Freq)) %>%
    mutate(Var1 = tolower(Var1))
  
    
  print(n)
  print(a.df)
  
plot <- ggplot(data = a.df, mapping = aes(reorder(x = Var1, desc(Freq)), y = Freq)) +
    geom_col(color = "black", fill = "cadetblue3") + 
    labs(
      title = paste0("Distribution of ", n, "'s reviews"),
      caption = "Source: Tech Review .xlsx file"
    ) +
    xlab("Analyst") +
    ylab("Review Count") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 7))

print(plot)
}
```

3: Data Preparation

  3.1: Select Data
  
  Todd wants us to grab everything, so lets select all of variables except for comments. Dropping closed date for now due to 
  missing values and inconsistency. Come back and try to repair it.
  
  Variables for different types of QA findings are decoded below. Other columns are renamed to be more usable. 
  
```{r}

var.decode <- function(tr.dataframe) {
  tr.dataframe <- tr.dataframe %>%
    select(`Start Date`, Project, `Project Description`, Analyst, `Test Type`,
          C1, C2, C3, C4, C5, C6, C7, RFT, `>2X`, `Sample IDs`, Comments) %>%
  
  rename("start_date" = `Start Date`, 
         "project_description" = `Project Description`,
         "test_type" = `Test Type`, 
         "missed_QEM" = C1, 
         "incorrect_result_reported" = C2,
         "reprocessing_Integration" = C3,
         "reprocessing_calculation" = C4,
         "LIMS_incompletation" = C5, 
         "GDP_misses" = C6,
         "missing_client_documentation" = C7,
         "back_and_forth" = `>2X`, 
         "sample_ID" = `Sample IDs`)
  
  return(tr.dataframe)
}

for(i in 1:length(tr.reviewers)){
  print(names(tr.reviewers[i]))
  tr.reviewers[[i]] <- var.decode(tr.reviewers[[i]])
}

hans <- as.data.frame(tr.reviewers$hans)
vir <- as.data.frame(tr.reviewers$vir)
kim <- as.data.frame(tr.reviewers$kim)
dolly <- as.data.frame(tr.reviewers$dolly)
clester <- as.data.frame(tr.reviewers$clester)
michael <- as.data.frame(tr.reviewers$michael)
sarah <- as.data.frame(tr.reviewers$sarah)
dennis <- as.data.frame(tr.reviewers$dennis)
kelly <- as.data.frame(tr.reviewers$kelly)
```


  3.2: Clean Data
  
  Kim and Dolly both have projects where the data entered for the first test is assumed to apply to the consecutive tests. This is
  corrected by applying a fill to the columns where this occurs. The goal of this step is to associate all testing with the analyst
  who performed it. Since QEMs are assigned per test, this will provide more accurate first-time-correct statistics for each analyst.
  
  Clester has a few rows with an empty analyst field. These observations will not aid us in analyzing QEMs per analyst, so these
  rows will be dropped from analysis.

```{R}
kim <- kim %>%
  fill(c(start_date, Project, project_description, Analyst, test_type), .direction = c("down"))

dolly <- dolly %>%
  fill(c(start_date, Project, Analyst, test_type), .direction = c("down")) %>%
    filter(Analyst != is.na(Analyst))

clester <- clester %>%
  filter(Analyst != is.na(Analyst))

michael <- michael %>%
  filter(Analyst != is.na(Analyst))

dennis <- dennis %>%
  filter(Analyst != is.na(Analyst))

kelly <- kelly %>%
  fill(c(start_date, Project, project_description, Analyst, test_type), .direction = c("down")) %>%
  filter(Analyst != is.na(Analyst)) 
```

#Encode QEMs as 0 or 1 to quantify assignment of QEMs to analysts.

```{r}
hans[is.na(hans)] = 0
  hans$missed_QEM <- ifelse(hans$missed_QEM != 0, 1, 0)
    hans$incorrect_result_reported <- ifelse(hans$incorrect_result_reported != 0, 1, 0)
      hans$reprocessing_Integration <- ifelse(hans$reprocessing_Integration != 0, 1, 0)
        hans$reprocessing_calculation <- ifelse(hans$reprocessing_calculation != 0, 1, 0)
          hans$LIMS_incompletation <- ifelse(hans$LIMS_incompletation != 0, 1, 0)
        hans$GDP_misses <- ifelse(hans$GDP_misses != 0, 1, 0)
      hans$missing_client_documentation <- ifelse(hans$missing_client_documentation != 0, 1, 0)
    hans$RFT <- ifelse(hans$RFT != 0, 1, 0)
  hans$back_and_forth <- ifelse(hans$back_and_forth != 0, 1, 0)
#----------------------------------------------------------------------------------------------  
vir[is.na(vir)] = 0
  vir$missed_QEM <- ifelse(vir$missed_QEM != 0, 1, 0)
    vir$incorrect_result_reported <- ifelse(vir$incorrect_result_reported != 0, 1, 0)
      vir$reprocessing_Integration <- ifelse(vir$reprocessing_Integration != 0, 1, 0)
        vir$reprocessing_calculation <- ifelse(vir$reprocessing_calculation != 0, 1, 0)
          vir$LIMS_incompletation <- ifelse(vir$LIMS_incompletation != 0, 1, 0)
        vir$GDP_misses <- ifelse(vir$GDP_misses != 0, 1, 0)
      vir$missing_client_documentation <- ifelse(vir$missing_client_documentation != 0, 1, 0)
    vir$RFT <- ifelse(vir$RFT != 0, 1, 0)
  vir$back_and_forth <- ifelse(vir$back_and_forth != 0, 1, 0)
#----------------------------------------------------------------------------------------------  
kim[is.na(kim)] = 0
  kim$missed_QEM <- ifelse(kim$missed_QEM != 0, 1, 0)
    kim$incorrect_result_reported <- ifelse(kim$incorrect_result_reported != 0, 1, 0)
      kim$reprocessing_Integration <- ifelse(kim$reprocessing_Integration != 0, 1, 0)
        kim$reprocessing_calculation <- ifelse(kim$reprocessing_calculation != 0, 1, 0)
          kim$LIMS_incompletation <- ifelse(kim$LIMS_incompletation != 0, 1, 0)
        kim$GDP_misses <- ifelse(kim$GDP_misses != 0, 1, 0)
      kim$missing_client_documentation <- ifelse(kim$missing_client_documentation != 0, 1, 0)
    kim$RFT <- ifelse(kim$RFT != 0, 1, 0)
  kim$back_and_forth <- ifelse(kim$back_and_forth != 0, 1, 0)
#----------------------------------------------------------------------------------------------  
dolly[is.na(dolly)] = 0
  dolly$missed_QEM <- ifelse(dolly$missed_QEM != 0, 1, 0)
    dolly$incorrect_result_reported <- ifelse(dolly$incorrect_result_reported != 0, 1, 0)
      dolly$reprocessing_Integration <- ifelse(dolly$reprocessing_Integration != 0, 1, 0)
        dolly$reprocessing_calculation <- ifelse(dolly$reprocessing_calculation != 0, 1, 0)
          dolly$LIMS_incompletation <- ifelse(dolly$LIMS_incompletation != 0, 1, 0)
        dolly$GDP_misses <- ifelse(dolly$GDP_misses != 0, 1, 0)
      dolly$missing_client_documentation <- ifelse(dolly$missing_client_documentation != 0, 1, 0)
    dolly$RFT <- ifelse(dolly$RFT != 0, 1, 0)
  dolly$back_and_forth <- ifelse(dolly$back_and_forth != 0, 1, 0)
#----------------------------------------------------------------------------------------------
clester[is.na(clester)] = 0
  clester$missed_QEM <- ifelse(clester$missed_QEM != 0, 1, 0)
    clester$incorrect_result_reported <- ifelse(clester$incorrect_result_reported != 0, 1, 0)
      clester$reprocessing_Integration <- ifelse(clester$reprocessing_Integration != 0, 1, 0)
        clester$reprocessing_calculation <- ifelse(clester$reprocessing_calculation != 0, 1, 0)
          clester$LIMS_incompletation <- ifelse(clester$LIMS_incompletation != 0, 1, 0)
        clester$GDP_misses <- ifelse(clester$GDP_misses != 0, 1, 0)
      clester$missing_client_documentation <- ifelse(clester$missing_client_documentation != 0, 1, 0)
    clester$RFT <- ifelse(clester$RFT != 0, 1, 0)
  clester$back_and_forth <- ifelse(clester$back_and_forth != 0, 1, 0)
#----------------------------------------------------------------------------------------------
michael[is.na(michael)] = 0
  michael$missed_QEM <- ifelse(michael$missed_QEM != 0, 1, 0)
    michael$incorrect_result_reported <- ifelse(michael$incorrect_result_reported != 0, 1, 0)
      michael$reprocessing_Integration <- ifelse(michael$reprocessing_Integration != 0, 1, 0)
        michael$reprocessing_calculation <- ifelse(michael$reprocessing_calculation != 0, 1, 0)
          michael$LIMS_incompletation <- ifelse(michael$LIMS_incompletation != 0, 1, 0)
        michael$GDP_misses <- ifelse(michael$GDP_misses != 0, 1, 0)
      michael$missing_client_documentation <- ifelse(michael$missing_client_documentation != 0, 1, 0)
    michael$RFT <- ifelse(michael$RFT != 0, 1, 0)
  michael$back_and_forth <- ifelse(michael$back_and_forth != 0, 1, 0)
#----------------------------------------------------------------------------------------------
sarah[is.na(sarah)] = 0
  sarah$missed_QEM <- ifelse(sarah$missed_QEM != 0, 1, 0)
    sarah$incorrect_result_reported <- ifelse(sarah$incorrect_result_reported != 0, 1, 0)
      sarah$reprocessing_Integration <- ifelse(sarah$reprocessing_Integration != 0, 1, 0)
        sarah$reprocessing_calculation <- ifelse(sarah$reprocessing_calculation != 0, 1, 0)
          sarah$LIMS_incompletation <- ifelse(sarah$LIMS_incompletation != 0, 1, 0)
        sarah$GDP_misses <- ifelse(sarah$GDP_misses != 0, 1, 0)
      sarah$missing_client_documentation <- ifelse(sarah$missing_client_documentation != 0, 1, 0)
    sarah$RFT <- ifelse(sarah$RFT != 0, 1, 0)
  sarah$back_and_forth <- ifelse(sarah$back_and_forth != 0, 1, 0) 
#----------------------------------------------------------------------------------------------
dennis[is.na(dennis)] = 0
  dennis$missed_QEM <- ifelse(dennis$missed_QEM != 0, 1, 0)
    dennis$incorrect_result_reported <- ifelse(dennis$incorrect_result_reported != 0, 1, 0)
      dennis$reprocessing_Integration <- ifelse(dennis$reprocessing_Integration != 0, 1, 0)
        dennis$reprocessing_calculation <- ifelse(dennis$reprocessing_calculation != 0, 1, 0)
          dennis$LIMS_incompletation <- ifelse(dennis$LIMS_incompletation != 0, 1, 0)
        dennis$GDP_misses <- ifelse(dennis$GDP_misses != 0, 1, 0)
      dennis$missing_client_documentation <- ifelse(dennis$missing_client_documentation != 0, 1, 0)
    dennis$RFT <- ifelse(dennis$RFT != 0, 1, 0)
  dennis$back_and_forth <- ifelse(dennis$back_and_forth != 0, 1, 0)
#----------------------------------------------------------------------------------------------
kelly[is.na(kelly)] = 0
  kelly$missed_QEM <- ifelse(kelly$missed_QEM != 0, 1, 0)
    kelly$incorrect_result_reported <- ifelse(kelly$incorrect_result_reported != 0, 1, 0)
      kelly$reprocessing_Integration <- ifelse(kelly$reprocessing_Integration != 0, 1, 0)
        kelly$reprocessing_calculation <- ifelse(kelly$reprocessing_calculation != 0, 1, 0)
          kelly$LIMS_incompletation <- ifelse(kelly$LIMS_incompletation != 0, 1, 0)
        kelly$GDP_misses <- ifelse(kelly$GDP_misses != 0, 1, 0)
      kelly$missing_client_documentation <- ifelse(kelly$missing_client_documentation != 0, 1, 0)
    kelly$RFT <- ifelse(kelly$RFT != 0, 1, 0)
  kelly$back_and_forth <- ifelse(kelly$back_and_forth != 0, 1, 0)
```

  3.3: Construct Data

  Data construct: RFT Rate. The RFT rate of each tech reviewer will be calculated below.

```{r}

```



