---
title: "Practicum 02"
output: html_notebook
---

Question 1: Complete the following queries using the customers, orders, and Router_info 
data. You should submit your queries and output in a word document. You will 
also be graded on creativity and complexity.

Question 1: Import the data into SQlite by creating 3 tables to host the data (10 points)

All code ran using the SQLite3 command line interface. Each tables was imported using the code listed below. 
For organization and access, each table was added to the database "CustomerDatabase.db". 

.mode csv
.separator ','

CREATE TABLE "Customers" (
	"CustomerID"	INTEGER,
	"FirstName"	TEXT,
	"LastName"	TEXT,
	"StreetAddress"	TEXT,
	"City"	TEXT,
	"State"	TEXT,
	"ZipeCode"	TEXT,
	"Telephone"	TEXT,
	"Purchases_Total"	TEXT,
	PRIMARY KEY("CustomerID")
);

.import customers.csv Customers
SELECT COUNT(*) FROM Customers
.save CustomerDatabase.db


CREATE TABLE Orders (
  "OrderID" INTEGER,
  "CustomerID" INTEGER,
  "SKU" TEXT,
  "Description" TEXT,
  "Cost" TEXT,
  "Year_Purchase" TEXT,
  PRIMARY KEY("OrderID")
);

.import orders.csv Orders
SELECT COUNT(*) FROM Orders
.save CustomerDatabase.db

CREATE TABLE Routers (
  "RMAID" INTEGER,
  "OrderID" INTEGER,
  "Status" TEXT,
  "Step" TEXT,
  "Reason" TEXT,
  "CustomerID" INTEGER,
  PRIMARY KEY("RMAID")
);

.import Router_info.csv Routers
SELECT COUNT(*) FROM Routers
.save CustomerDatabase.db



Question 2: Explore the data, what do you see and how would you connect all 3 of these
tables? (2.5 points)

Work performed in R using RSQLite

all tables were connected in a single database file by saving the three imported tables using
.save CustomerDatabase.db in the SQLite3 command line.

Product returns by state and by city are summarized below. Additionally, product stability data 
was generated by joining the results of the routers returned to the product SKU, and grouping by 
by the reason for the product return. This provides statistics that can be used to determine which router
is most likely to become defective. In this case, it is the Basic Switch 10/100/1000 BaseT 48 port. 


#Check to see if there is a method to check for missing values in all columns.
```{r}
library(RSQLite)
library(tidyverse)

db <- dbConnect(SQLite(), 
                dbname = "C:/Users/mastl/Documents/DA5020/sqlite-tools-win32-x86-3380500/CustomerDatabase.db")

dbListTables(db)

#Explore Data

#Count of service calls per State
sqlCmd1 <- "SELECT COUNT(*), State
            FROM Customers
            GROUP BY State;"

#Count of service calls per City
sqlCmd2 <- "SELECT COUNT(*), City
            FROM Customers
            GROUP BY City;"


sqlCmd3 <- "SELECT SKU, Description, Reason, COUNT(*) AS Occurance_Number
            FROM (SELECT Orders.*, Routers.*
	                FROM Orders
	                JOIN Routers ON Routers.OrderID = Orders.OrderID)
            GROUP BY SKU, Reason
            ORDER BY Reason, Occurance_Number;"

stateBreakdown <- dbGetQuery(db, sqlCmd1)
print(stateBreakdown)

cityBreakdown <- dbGetQuery(db, sqlCmd2)
print(cityBreakdown)

productBreakdown <- dbGetQuery(db, sqlCmd3)
print(productBreakdown)

#Join all tables

sqlCmd4 <- "SELECT *
            FROM (SELECT Customers.*, Orders.*, Routers.*
	                FROM Customers
	                JOIN Orders on Orders.CustomerID = Customers.CustomerID
	                JOIN Routers on Routers.CustomerID = Customers.CustomerID);"

tableJoin <- dbGetQuery(db, sqlCmd4)
print(tableJoin)
```


Question 3: Create a query using Select, where, from on a table of your using (2.5 points)

Below is an example query which searches the table "Customers" for customers with the first name 'Jake'. The query 
returns all information related to customers with the first name Jake that is contained within the Customers table.

```{r}
sqlCmd5 <- "SELECT *
            FROM Customers
            WHERE Customers.FirstName == 'Jake';"

firstNameSearch <- dbGetQuery(db, sqlCmd5)
print(firstNameSearch)
```

Question 4: Create a query that joins the tables (5 points)

Below is a query that uses the primary keys CustomerID, OrderID, and RMAID to join all three tables within the database. 

```{r}
sqlCmd6 <- "SELECT *
            FROM (SELECT Customers.*, Orders.*, Routers.*
	                FROM Customers
	                JOIN Orders on Orders.CustomerID = Customers.CustomerID
	                JOIN Routers on Routers.CustomerID = Customers.CustomerID);"

tableJoin <- dbGetQuery(db, sqlCmd6)
print(tableJoin)
```

Question 5: Create a left join query (0 points)

```{r}
sqlCmd7 <- "SELECT *
            FROM Customers
            LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;"

leftJoin <- dbGetQuery(db, sqlCmd7)
print(leftJoin)
```

Question 6: Create a query that uses the joined data from question 2 and includes Group BY,
HAVING, Order By (5 points)

The command below joins all tables using a subquery, and uses the SUM function to sum the purchases_total. 
The summed total_puchases column is named under the alias "Summed_Purchases" data is summarized by state using the GROUP BY State query. A filter command to remove states where summed purchases are less than 25 is applied to the value produced by the GROUP BY function using the HAVING command below. The remaining states are ordered by summed_purchases using the ORDER BY command.

```{r}
sqlCmd8 <- "SELECT State, ZipeCode, SUM(Purchases_Total) AS Summed_Purchases
            FROM (SELECT Customers.*, Orders.*, Routers.*
	                FROM Customers
	                JOIN Orders on Orders.CustomerID = Customers.CustomerID
	                JOIN Routers on Routers.CustomerID = Customers.CustomerID)
					  GROUP BY State
					  HAVING Summed_Purchases >= 25
					  ORDER BY Summed_Purchases DESC;"

havingCmd <- dbGetQuery(db, sqlCmd8)
print(havingCmd)
```

Question 7: Create a query that counts and distinctly counts (5 points)

The command below displays the number of states and the number of distinct states that are available
within the Customers table. in the column "States", we see a high value because multiples calls in a single
state were made and considered, whereas in the "Distinct_States" column a count was only generated for the first
time that a new state was encountered. This also confirms that purchases were made in all 50 US states.

#See if you can get the graph in Teena's practicum looking good.

```{r}
sqlCmd9 <- "SELECT COUNT(State) AS States, COUNT(DISTINCT(State)) AS Distinct_States
            FROM Customers;"

distinctCmd <- dbGetQuery(db, sqlCmd9)
print(distinctCmd)
```

Question 8: Create a query that finds the MIN, MAX, Sum, order by desc (5 points)

```{r}
sqlCmd10 <- "SELECT State, MIN(Purchases_Total) AS Min_Purchase, 
                           MAX(Purchases_Total) AS Max_Purchase, 
                           SUM(Purchases_Total) AS Summed_Purchase
             FROM Customers
             GROUP BY State 
             ORDER BY SUM(Purchases_Total) DESC;"

sumCmd <- dbGetQuery(db, sqlCmd10)
print(sumCmd)
```

Question 9: Create a query that uses Between, and, <, > (5 points)

```{r}
sqlCmd11 <- "SELECT *
           FROM Orders
           WHERE Year_Purchase BETWEEN 2018 AND 2021 
           AND Cost > 10 AND Cost < 300;"

betweenCmd <- dbGetQuery(db, sqlCmd11)
print(betweenCmd)
```

Question 10: Create a query that uses a wildcard, a join, and a group by clause (5 points)

```{r}
sqlCmd12 <- "SELECT State, Purchases_Total, SKU, 
             SUM(Purchases_Total) AS Summed_Purchases
             FROM (SELECT Customers.*, Orders.*
	                 FROM Customers
	                 JOIN Orders on Orders.CustomerID = Customers.CustomerID)
             WHERE State LIKE '%Virginia%'
             GROUP BY State;"

wildcardCmd <- dbGetQuery(db, sqlCmd12)
print(wildcardCmd)
```

Question 11: Create a query that finds the average and uses one of the following AND, OR, NOT (5
points)

```{r}
sqlCmd13 <- "SELECT State, Purchases_Total, AVG(Purchases_Total) AS Average_Purchase
             FROM Customers
             WHERE State = 'Virginia' OR state = 'North Carolina'
             GROUP BY State;"

averageCmd <- dbGetQuery(db, sqlCmd13)
print(averageCmd)
```


Part 2: Complete the following queries using the HIV_info and country_info data. You 
should submit your queries and output in a word document. You will also be 
graded on creativity and complexity. You will need to create the tables and 
import the data before you can complete the queries 


Question 1: Look at both data sets what do you observe? How would you join the data? (5
points)


.mode csv
.separator ','

CREATE TABLE "HIV_Info" (
  "Entity" TEXT,
  "Year" INTEGER,
  "number_of_people_living_with_HIV" TEXT,
  "deaths<5" INTEGER,
  "deaths>=70" INTEGER,
  "deaths_5-14" INTEGER,
  "deaths_15-49" INTEGER,
  "deaths_50-69" INTEGER,
  "deaths_total" INTEGER,
  "new_cases_of_hiv_infection" INTEGER,
  "number_of_people_infected_with_hiv" INTEGER
);

.import --csv --skip 1 HIV_info.csv HIV_Info
ALTER TABLE HIV_Info RENAME Entity TO Country

CREATE TABLE "Country_Info" (
	"Country"	TEXT,
	"Year" INTEGER,
	"Country_Population" INTEGER,
	"GDP_per_capital" INTEGER,
	"unemployment rate" INTEGER,
	"School_enrollment_rate" INTEGER
);

.import --csv --skip 1 country_info.csv Country_Info

UPDATE Country_Info SET GDP_per_capital = NULL WHERE GDP_per_captial = "Null"
UPDATE Country_Info SET unemployment_rate = NULL WHERE unemployment_rate = "Null"
UPDATE Country_Info SET School_enrollment_rate = NULL WHERE School_enrollment_rate = "Null"


#Will discuss this one with Teena. 
#Will add Teena's dimensional analysis of tables and proof of common columns

The first point of interest are the NULL values apparent in the country_info data set. A summary of
the NULL values is presented below. Due to the relatively small size of the data set, rows 
containing null values were not removed. Imputation of the null values was also not performed, 
as imputing over 31% of the data set in some columns would cause the artificial values
to have a disproportionate impact on the mean.

The data was joined by a double inner join method. The join was set up during creation of the table, 
where the column name "Entity" in HIV_Info was altered to match the "Country" column in 
Country_Info using the SQLite command ALTER TABLE and RENAME COLUMN to change "Entity" to "Country". 

The double inner join of the data was performed by using both the Country and Year column to create
a surrogate 'primary key' to match up the data in the two tables.

#Maybe mention how/why you replace the decimal.
#Mention that this happens with CSV files due to comma separation.
The third point of interest arises with the comparison of the columns "number_of_people_living_with_HIV"
and "number_of_people_infected_with_HIV". In the first column, there is a formatting error where two different
conventions of representing large numbers are mixed up. If this data were presented to an American
audience, the first column value for Bermuda in 2007 should read "92.076", and the second column is a rounded version
of the first column based on this convention.

Conversion from the European to American notation was performed by removal of the 

#Check all columns.
A fourth point of interest is that although the .csv file specifies country data, it includes North America which is 
a continent. North American HIV values in the table HIV_Info seem to be summed values from Bermuda, Canada, and the 
United States per year.

```{r}
library(RSQLite)
library(tidyverse)

db2 <- dbConnect(SQLite(), 
                dbname = "C:/Users/mastl/Documents/DA5020/sqlite-tools-win32-x86-3380500/HIV_Country_Info.db")

#List of Tables.
#Try to remove the HIV_Info; table.
dbListTables(db2)
#-------------------------------------------------------------------------------------------------------------

#First 5 rows of HIV_Info table.
HIV_info <- dbGetQuery(db2, "SELECT * FROM HIV_Info LIMIT 5")
print(HIV_info)

#First 5 rows of Country_Info table.
Country_info <- dbGetQuery(db2, "SELECT * FROM Country_Info LIMIT 5")
print(Country_info)

#First five rows of combined table. 
sqlCmd14 <- "SELECT *
             FROM HIV_Info
             INNER JOIN Country_Info ON Country_Info.Country = HIV_Info.Country
             AND Country_Info.Year = HIV_Info.Year
             LIMIT 5;"

joined_tables <- dbGetQuery(db2, sqlCmd14)
print(joined_tables)

#-------------------------------------------------------------------------------------------------------------
#HIV Data Summary
#Count and Distinct Count from Teena's Code.

data_explore1 <- dbGetQuery(db2, sqlCmd14)
print(data_explore1)

## evaluating the number of observations and variables in the HIV_Info Table.
dbGetQuery(db2, 'SELECT COUNT(*) FROM HIV_info')
dbGetQuery(db2, 'SELECT * FROM HIV_info LIMIT 2')

## there are 44 observations and 11 variables in HIV_info table

sqlCmd15 <- 'SELECT AVG("deaths<5"), AVG("deaths>=70"), 
                    AVG("deaths_5-14"), AVG("deaths_15-49"),
                    AVG("deaths_50-69"), AVG("deaths_total"),
                    AVG("new_cases_of_hiv_infection"), AVG("number_of_people_infected_with_HIV")
                    FROM HIV_Info'
                    
sqlCmd16 <- 'SELECT MIN("deaths<5"), MIN("deaths>=70"), 
                    MIN("deaths_5-14"), MIN("deaths_15-49"),
                    MIN("deaths_50-69"), MIN("deaths_total"),
                    MIN("new_cases_of_hiv_infection"), MIN("number_of_people_infected_with_HIV")
                    FROM HIV_Info'
                    
sqlCmd17 <- 'SELECT MAX("deaths<5"), MAX("deaths>=70"), 
                    MAX("deaths_5-14"), MAX("deaths_15-49"),
                    MAX("deaths_50-69"), MAX("deaths_total"),
                    MAX("new_cases_of_hiv_infection"), MAX("number_of_people_infected_with_HIV")
                    FROM HIV_Info'

sqlCmd18 <- 'SELECT (COUNT(*)-COUNT(Country)) AS Country_Null,
	                  (COUNT(*)-COUNT(Year)) AS Year_Null,
	                  (COUNT(*)-COUNT(number_of_people_living_with_HIV)) AS number_of_people_living_with_HIV_Null,
	                  (COUNT(*)-COUNT("deaths<5")) AS "deaths<5_null",
	                  (COUNT(*)-COUNT("deaths>=70")) AS "deaths>=70_Null",
	                  (COUNT(*)-COUNT("deaths_5-14")) AS "deaths_5-14_Null",
	                  (COUNT(*)-COUNT("deaths_15-49")) AS "deaths_15-49_Null",
	                  (COUNT(*)-COUNT("deaths_50-69")) AS "deaths_50-69_Null",
	                  (COUNT(*)-COUNT(deaths_total)) AS deaths_total_Null,
	                  (COUNT(*)-COUNT(new_cases_of_hiv_infection)) AS new_cases_of_hiv_infection_Null
             FROM HIV_Info'

dataAverage <- dbGetQuery(db2, sqlCmd15)
print(dataAverage)

dataMin <- dbGetQuery(db2, sqlCmd16)
print(dataMin)

dataMax <- dbGetQuery(db2, sqlCmd17)
print(dataMax)

nullValues <- dbGetQuery(db2, sqlCmd18)
print(nullValues)

## 1. checking the columns Country with year in the HIV_info table to see if it uniquely 
# identify the records for each observation
dbGetQuery(db2, 'SELECT COUNT(DISTINCT Country) FROM HIV_info')

# it shows there are four Countries information in the table

dbGetQuery(db2, 'SELECT DISTINCT Country FROM HIV_info')

# the four Countries are Bermuda, Canada, North America continent and United States

# checking the year column
dbGetQuery(db2, 'SELECT COUNT(DISTINCT Year) FROM HIV_info')

# Year variables hold information for 11 years
dbGetQuery(db2, 'SELECT DISTINCT Year FROM HIV_info')
# information is from 2007-2017

# checking if the year are for different countries
dbGetQuery(db2, 'SELECT Count(Country), COUNT(Year) 
                 FROM HIV_info 
                 WHERE Country = "Bermuda" AND Year BETWEEN "2007" AND "2017"')

dbGetQuery(db2, 'SELECT Count(Country), COUNT(Year) 
                 FROM HIV_info 
                 WHERE COuntry = "Canada" AND Year BETWEEN "2007" AND "2017"')


dbGetQuery(db2, 'SELECT Count(Country), COUNT(Year) 
                 FROM HIV_info 
                 WHERE Country = "North America" AND Year BETWEEN "2007" AND "2017"')


dbGetQuery(db2, 'SELECT Count(Country), COUNT(Year) 
                 FROM HIV_info 
                 WHERE Country = "United States" AND Year BETWEEN "2007" AND "2017"')

# it shows the observations from 2007-2017 for each Country, hence 44 observations
# this tables stores the information regarding the number of people infected with
# HIV and the number of deaths in different age group in four Countries from year 2007-2017

#-------------------------------------------------------------------------------------------------------------
#Country_Info data summary 
#Add code from Teena's table.

## evaluating the number of observations and variables in the Country_Info Table. 

dbGetQuery(db2, 'SELECT COUNT(*) FROM country_info')
dbGetQuery(db2, 'SELECT * FROM country_info LIMIT 2')

## there are 44 observations and 6 variables in country_info table

sqlCmd19 <- "SELECT AVG(Country_Population), AVG(GDP_per_capital), 
	                  AVG(unemployment_rate), AVG(School_enrollment_rate)
             FROM Country_Info"

sqlCmd20 <- "SELECT MIN(Country_Population), MIN(GDP_per_capital), 
	                  MIN(unemployment_rate), MIN(School_enrollment_rate)
             FROM Country_Info"

sqlCmd21 <- "SELECT MAX(Country_Population), MAX(GDP_per_capital), 
	                  MAX(unemployment_rate), MAX(School_enrollment_rate)
             FROM Country_Info"

sqlCmd22 <- 'SELECT (COUNT(*)-COUNT(Country_Population)) AS Country_Population_Null,
	                  (COUNT(*)-COUNT(GDP_per_capital)) AS GDP_per_capital_Null,
	                  (COUNT(*)-COUNT(unemployment_rate)) AS unemployment_rate_Null,
	                  (COUNT(*)-COUNT(School_enrollment_rate)) AS School_enrollment_rate_Null
             FROM Country_Info'

dataAverage2 <- dbGetQuery(db2, sqlCmd19)
print(dataAverage2)

dataMin2 <- dbGetQuery(db2, sqlCmd20)
print(dataMin2)

dataMax2 <- dbGetQuery(db2, sqlCmd21)
print(dataMax2)

nullValues2 <- dbGetQuery(db2, sqlCmd22)
print(nullValues2)

## 2. checking the Country and year column if it is key for the country_info table

dbGetQuery(db2, 'SELECT COUNT(DISTINCT Country) FROM country_info')

# it shows there are four countries information in the table

dbGetQuery(db2, 'SELECT DISTINCT Country FROM country_info')

# the four Countries are Bermuda, Canada, North America continent and United States

dbGetQuery(db2, 'SELECT COUNT(DISTINCT Year) FROM country_info')

# Year variables hold information for 11 years
dbGetQuery(db2, 'SELECT DISTINCT Year FROM country_info')
# information is from 2007-2017 

# checking if the year are for different countries
dbGetQuery(db2, 'SELECT Count(Country), COUNT(Year) 
                 FROM country_info 
                 WHERE Country = "Bermuda" AND Year BETWEEN "2007" AND "2017"')

dbGetQuery(db2, 'SELECT Count(Country), COUNT(Year) 
                 FROM country_info 
                 WHERE Country = "Canada" AND Year BETWEEN "2007" AND "2017"')


dbGetQuery(db2, 'SELECT Count(Country), COUNT(Year) 
                 FROM country_info 
                 WHERE Country = "North America" AND Year BETWEEN "2007" AND "2017"')


dbGetQuery(db2, 'SELECT Count(Country), COUNT(Year) 
                 FROM country_info 
                 WHERE Country = "United States" AND Year BETWEEN "2007" AND "2017"')

# it shows the observation for four countries from 2007-2017 
# country_info table  stores the population, information, GDP per capital, 
# unemployment rate and school enrollment rate in Bermuda, Canada, North America and
# United States from 2007-2017

## Both the tables can be joined on country with year column, as it together 
# identifies the observations in both the tables

```

Question 2: Select the Country, Year, new_cases_of_hiv_infection, and
School_enrollment_rate then join the data hiv_info to the country_info table
on Entity/Country and year for only North America (10 points)

```{r}
sqlCmd15 <- "SELECT Country, Year, new_cases_of_hiv_infection, 
             School_enrollment_rate
             FROM (SELECT *
				           FROM HIV_Info
				           INNER JOIN Country_Info ON Country_Info.Country = HIV_Info.Country 
				           AND Country_Info.Year = HIV_Info.Year)
             WHERE Country = 'North America'"

hivCountryJoin <- dbGetQuery(db2, sqlCmd15)
print(hivCountryJoin)

#-------------------------------------------------------------------------------------
ggplot(data = hivCountryJoin, mapping = aes(x = Year, y = new_cases_of_hiv_infection)) +
  geom_point(color = 'red') +
  labs(
    title = "New Cases of HIV per Year in North America",
    caption = "Source: HIV_Info and Country_Info on NEU Canvas Page"
  ) +
  xlab("Year") +
  ylab("Number of People Living with HIV") +
  theme_bw()

ggplot(data = hivCountryJoin, mapping = aes(x = Year, y = School_enrollment_rate)) +
  geom_point(color = 'blue') +
    labs(
    title = "School Enrollment Rate per Year in North America",
    caption = "Source: HIV_Info and Country_Info on NEU Canvas Page"
  ) +
  xlab("Year") +
  ylab("School Enrollment Rate") +
  theme_bw()
```


Question 3: Select columns Country, Year, Country_Population and get the percentage of
people living with HIV and percentage of deaths from HIV then join the data
hiv_info to the country_info table on Entity/Country and year for only North
America (10 points)

Both parameters were defined within the context of total population size. The country and year column
were selected from the HIV_Info table, while the country_population column was selected from the country_Info
table. The column 'number_of_people_living_with_HIV' is declared using the european notation which features commas
instead of decimal points. Commas were removed using the REPLACE function and divided by 1000 for proper conversion
to numeric notation.

The column 'percent_living' is defined as the number of individuals living with HIV divided by the total population 
of the given country, multiplied by 100. To facilitate the division of integers, the function CAST was used to handle
'number_of_people_living_with_HIV' as a real value in order to obtain values that contain decimals. 

The column 'Percent_Death' is defined as the number of individuals who have died from HIV divided by the total population
of the given country, multiplied by 100. The data type of 'Deaths_Total' was similarly manipulated from integer to real
value in order to produces values which contain decimals.

Each calculated value was rounded to 5 decimal points to analysis the small differences in values over each year.

```{r}
sqlCmd16 <- "SELECT Country, Year,
	           ROUND((CAST(REPLACE(number_of_people_living_with_HIV, ',', '')/1000 AS REAL)/Country_Population)*100, 5) AS                            Percent_Living,
	           ROUND((CAST(deaths_total AS REAL)/Country_Population)*100, 5) AS Percent_Death,
	           Country_Population
             FROM (SELECT *
				           FROM HIV_Info
				           INNER JOIN Country_Info ON HIV_Info.Country = Country_Info.Country AND
						                                  HIV_Info.Year = Country_Info.Year)
             WHERE Country = 'North America'"

hivPercentage <- dbGetQuery(db2, sqlCmd16)
print(hivPercentage)

#-------------------------------------------------------------------------------
ggplot(data = hivPercentage, mapping = aes(x = Year, y = Percent_Living)) +
  geom_point(color = 'red') +
  labs(
    title = "Percentage of People Living with HIV per Year in North America",
    caption = "Source: HIV_Info and Country_Info on NEU Canvas Page"
  ) +
  xlab("Year") +
  ylab("% of People Living with HIV") +
  theme_bw()

ggplot(data = hivPercentage, mapping = aes(x = Year, y = Percent_Death)) +
  geom_point(color = 'blue') +
   labs(
    title = "Percentage of Population Death per Year from HIV",
    caption = "Source: HIV_Info and Country_Info on NEU Canvas Page"
  ) +
  xlab("Year") +
  ylab("% of population death from HIV") +
  theme_bw()
```


Question 4: Select columns Country and get the SUM of the
number_of_people_living_with_HIV divided by Country_Population then join
the data hiv_info to the country_info table on Entity/Country and year not in
North America (10 point)

The first step taken to achieve this value was to replace the comma within the values 
of number_of_people_living_with_HIV so that the values can be handled as integers. As noted 
in question 1, it seems that the values entered into the number_of_people_living_with_HIV 
column were entered using a European notation, where commas are used in place of periods. Without
making this assumption, the values entered into the column are clearly wrong based on how in many 
instances the value in number_of_people_living_with_HIV outnumber the country's population. By
removing the commas with REPLACE and dividing by 1000, the value in number_of_people_living_with_HIV 
now matches the column "number_of_people_infected_with_HIV".

With this corrected value in place, the sum of number_of_people_living_with_HIV was taken using the 
SUM aggregate function, and was divided by the population of that country. The aggregate function was
grouped by country to calculate the proportion of total infections against the total population in the 
year 2007. An inner join was performed to access the Country_Info.Country_Population column.

#Question: is it SUM(number_of_people_living_with_HIV) / Country_Info.Country_Population 
#             or SUM(number_of_people_living_with_HIV / Country_Info.Country_Population)

#4 groups for four countries
#The way the question is worded could mean either.
#Ask TA about this.

```{r}
sqlCmd23 <- "SELECT HIV_Info.Country, HIV_Info.Year, CAST(((SUM(REPLACE(HIV_Info.number_of_people_living_with_HIV, ',', '')/1000))) AS                     REAL)/Country_Info.Country_Population AS Proportion
             FROM HIV_Info
             INNER JOIN Country_Info ON Country_Info.Country = HIV_Info.Country 
                        AND Country_Info.Year = HIV_Info.Year
             WHERE HIV_Info.Country IS NOT 'North America'
             GROUP BY HIV_Info.Country"

countryDivision <- dbGetQuery(db2, sqlCmd23)
print(countryDivision)
```


SELECT HIV_Info.Country, HIV_Info.Year,(SUM(REPLACE(HIV_Info.number_of_people_living_with_HIV, ',', ''))/1000), Country_Info.Country_Population
FROM HIV_Info
INNER JOIN Country_Info ON Country_Info.Country = HIV_Info.Country 
           AND Country_Info.Year = HIV_Info.Year
WHERE HIV_Info.Country IS NOT 'North America'
GROUP BY HIV_Info.Country


Question 5: Produce 5 unique and interesting queries using both datasets. Unique means
that you do not use the same query 5 times and add small parts to it. (15 points,
3 points each)

#Query 3
A Common Table Expression was implemented to calculate the average unemployment rate and average school 
enrollment rate in each country. North America was excluded from the data set as it appears to represent
summed values of all countries displayed, and Bermuda was removed from analysis due to most of its associated
values for these columns being NULL values.

Average Infection rate was calculated by dividing the number of people infected with HIV by the Country Population 
and taking the average value of each Country. these results were joined with the CTE in order to compare average infection
rate, average unemployment rate, and average school enrollment rate between the US and Canada.

#Query 4
#Try using negative exponent to replace square root. 
#Fix table names for 
#Try to corrolate a few more variables to see if there are stronger correlations.

```{r}
#Query 1: Correlated variables.

hiv_sch_enroll_cor <- dbGetQuery(db2, 'WITH subquery AS (
                                                        SELECT Country, Year, Country_Population, School_enrollment_rate
                                                        FROM country_info
                                                        WHERE School_enrollment_rate IS NOT "Null")
                                                        
                                       SELECT h.Country AS Country,
                                              h.Year, h.number_of_people_infected_with_HIV, subquery.School_enrollment_rate
                                       FROM HIV_info AS h
                                       INNER JOIN subquery ON h.Country=subquery.Country AND 
                                                              h.Year=subquery.Year
                                       WHERE h.Year BETWEEN 2007 AND 2017
                                       GROUP BY h.Year
                                       ORDER BY subquery.School_enrollment_rate DESC')

print(hiv_sch_enroll_cor)

#Query 2: Effect of growth in population to unemployment rate.

canada_diff_q <- 'SELECT c1.Country, c1.Country_Population AS pop2007, 
	                       c2.Country_Population AS pop2017, 
	                       c2.Country_Population-c1.Country_Population AS Diff,
	                       c1.unemployment_rate AS employ2007, 
	                       c2.unemployment_rate AS employ2017, 
	                       ROUND(c2.unemployment_rate - c1.unemployment_rate, 3) AS employ_diff
                  FROM country_info AS c1
                  JOIN country_info AS c2
                  USING(Country)
                  WHERE Country="Canada"
                  AND c1.Year = 2007 AND c1.Year= c2.Year-10'

canada_diff_r <- dbGetQuery(db2, canada_diff_q)
print(canada_diff_r)


#Query 3: Compare Average Infection Rates, average unemployment rate, and average school enrollment rate between US and Canada
sqlCmd25 <- "WITH CTE_Average AS
            (SELECT Country,  AVG(unemployment_rate) AS Average_Unemployment_Rate, 
		                AVG(School_enrollment_rate) AS Average_School_enrollment_rate,
		                Country_Population
            FROM Country_Info
            WHERE Country IS NOT 'Bermuda' AND Country IS NOT 'North America'
            GROUP BY Country)

            SELECT HIV_Info.Country, HIV_Info.number_of_people_infected_with_hiv, 
	                 CTE_Average.Country_Population, 
	                 AVG(CAST(number_of_people_infected_with_hiv AS REAL)/CAST(Country_Population AS REAL)) AS 
	                 Average_Infection_Rate,
	                 CTE_Average.Average_Unemployment_Rate, 
	                 CTE_Average.Average_School_enrollment_rate
            FROM CTE_Average
	          JOIN HIV_Info on CTE_Average.Country = HIV_Info.Country
            GROUP BY HIV_Info.Country"

rate_comparison <- dbGetQuery(db2, sqlCmd25)
print(rate_comparison)

#Query 4: Deviation from the Mean
sqlCmd26 <- "WITH CTE_Deviation AS(
             SELECT Country_Info.Country, Country_Info.Year, HIV_Info.number_of_people_infected_with_hiv, 
	                  Country_Info.Country_Population, 
	                  AVG(CAST(HIV_info.number_of_people_infected_with_hiv AS REAL)/CAST(Country_Info.Country_Population AS REAL)*100)
		                AS Average_Infection_Percentage
             FROM Country_Info
             INNER JOIN HIV_Info ON Country_Info.Country = HIV_Info.Country AND
		                                Country_Info.Year = HIV_Info.Year
             WHERE Country_Info.Country IS NOT 'North America'
             GROUP BY Country_Info.Country
)
             SELECT HIV_Info.Country, HIV_Info.Year, HIV_Info.number_of_people_infected_with_hiv, 
	                  Country_Info.Country_Population, 
	                  Average_Infection_Percentage - (CAST(HIV_Info.number_of_people_infected_with_hiv AS                                                    REAL)/CAST(Country_Info.Country_Population AS REAL)*100)
	                  AS Infection_Percentage_Deviation,
	                  CTE_Deviation.Average_Infection_Percentage
             FROM CTE_Deviation
             INNER JOIN HIV_Info ON CTE_Deviation.Country = HIV_Info.Country
             INNER JOIN Country_Info ON HIV_Info.Country = Country_Info.Country AND
						                            HIV_Info.Year = Country_Info.Year"

infection_deviation <- dbGetQuery(db2, sqlCmd26)
print(infection_deviation)

#Query 5: check that North American values are sums of the other three countries.

```