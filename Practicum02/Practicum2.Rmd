---
title: "Practicum 02"
output: html_notebook
---

Question 1: Complete the following queries using the customers, orders, and Router_info 
data. You should submit your queries and output in a word document. You will 
also be graded on creativity and complexity.

Question 1: Import the data into SQlite by creating 3 tables to host the data (10 points)

All code ran using the SQLite3 command line interface. Each tables was imported using the code listed below. 
For organization and access, each table was added to the database "CustomerDatabase.db". 

.mode csv
.separator ','

CREATE TABLE "Customers" (
	"CustomerID"	INTEGER,
	"FirstName"	TEXT,
	"LastName"	TEXT,
	"StreetAddress"	TEXT,
	"City"	TEXT,
	"State"	TEXT,
	"ZipeCode"	TEXT,
	"Telephone"	TEXT,
	"Purchases_Total"	TEXT,
	PRIMARY KEY("CustomerID")
);

.import customers.csv Customers
SELECT COUNT(*) FROM Customers
.save CustomerDatabase.db


CREATE TABLE Orders (
  "OrderID" INTEGER,
  "CustomerID" INTEGER,
  "SKU" TEXT,
  "Description" TEXT,
  "Cost" TEXT,
  "Year_Purchase" TEXT,
  PRIMARY KEY("OrderID")
);

.import orders.csv Orders
SELECT COUNT(*) FROM Orders
.save CustomerDatabase.db

CREATE TABLE Routers (
  "RMAID" INTEGER,
  "OrderID" INTEGER,
  "Status" TEXT,
  "Step" TEXT,
  "Reason" TEXT,
  "CustomerID" INTEGER,
  PRIMARY KEY("RMAID")
);

.import Router_info.csv Routers
SELECT COUNT(*) FROM Routers
.save CustomerDatabase.db



Question 2: Explore the data, what do you see and how would you connect all 3 of these
tables? (2.5 points)

Work performed in R using RSQLite

all tables were connected in a single database file by saving the three imported tables using
.save CustomerDatabase.db in the SQLite3 command line.

Product returns by state and by city are summarized below. Additionally, product stability data 
was generated by joining the results of the routers returned to the product SKU, and grouping by 
by the reason for the product return. This provides statistics that can be used to determine which router
is most likely to become defective. In this case, it is the Basic Switch 10/100/1000 BaseT 48 port. 


#Check to see if there is a method to check for missing values in all columns.
```{r}
library(RSQLite)
library(tidyverse)

db <- dbConnect(SQLite(), 
                dbname = "C:/Users/mastl/Documents/DA5020/sqlite-tools-win32-x86-3380500/CustomerDatabase.db")

dbListTables(db)

#Explore Data

#Count of service calls per State
sqlCmd1 <- "SELECT COUNT(*), State
            FROM Customers
            GROUP BY State;"

#Count of service calls per City
sqlCmd2 <- "SELECT COUNT(*), City
            FROM Customers
            GROUP BY City;"


sqlCmd3 <- "SELECT SKU, Description, Reason, COUNT(*) AS Occurance_Number
            FROM (SELECT Orders.*, Routers.*
	                FROM Orders
	                JOIN Routers ON Routers.OrderID = Orders.OrderID)
            GROUP BY SKU, Reason
            ORDER BY Reason, Occurance_Number;"

stateBreakdown <- dbGetQuery(db, sqlCmd1)
print(stateBreakdown)

cityBreakdown <- dbGetQuery(db, sqlCmd2)
print(cityBreakdown)

productBreakdown <- dbGetQuery(db, sqlCmd3)
print(productBreakdown)

#Join all tables

sqlCmd4 <- "SELECT *
            FROM (SELECT Customers.*, Orders.*, Routers.*
	                FROM Customers
	                JOIN Orders on Orders.CustomerID = Customers.CustomerID
	                JOIN Routers on Routers.CustomerID = Customers.CustomerID);"

tableJoin <- dbGetQuery(db, sqlCmd4)
print(tableJoin)
```


Question 3: Create a query using Select, where, from on a table of your using (2.5 points)

Below is an example query which searches the table "Customers" for customers with the first name 'Jake'. The query 
returns all information related to customers with the first name Jake that is contained within the Customers table.

```{r}
sqlCmd5 <- "SELECT *
            FROM Customers
            WHERE Customers.FirstName == 'Jake';"

firstNameSearch <- dbGetQuery(db, sqlCmd5)
print(firstNameSearch)
```

Question 4: Create a query that joins the tables (5 points)

Below is a query that uses the primary keys CustomerID, OrderID, and RMAID to join all three tables within the database. 

```{r}
sqlCmd6 <- "SELECT *
            FROM (SELECT Customers.*, Orders.*, Routers.*
	                FROM Customers
	                JOIN Orders on Orders.CustomerID = Customers.CustomerID
	                JOIN Routers on Routers.CustomerID = Customers.CustomerID);"

tableJoin <- dbGetQuery(db, sqlCmd6)
print(tableJoin)
```

Question 5: Create a left join query (0 points)

```{r}
sqlCmd7 <- "SELECT *
            FROM Customers
            LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;"

leftJoin <- dbGetQuery(db, sqlCmd7)
print(leftJoin)
```

Question 6: Create a query that uses the joined data from question 2 and includes Group BY,
HAVING, Order By (5 points)

The command below joins all tables using a subquery, and uses the SUM function to sum the purchases_total. 
The summed total_puchases column is named under the alias "Summed_Purchases" data is summarized by state using the GROUP BY State query. A filter command to remove states where summed purchases are less than 25 is applied to the value produced by the GROUP BY function using the HAVING command below. The remaining states are ordered by summed_purchases using the ORDER BY command.

```{r}
sqlCmd8 <- "SELECT State, ZipeCode, SUM(Purchases_Total) AS Summed_Purchases
            FROM (SELECT Customers.*, Orders.*, Routers.*
	                FROM Customers
	                JOIN Orders on Orders.CustomerID = Customers.CustomerID
	                JOIN Routers on Routers.CustomerID = Customers.CustomerID)
					  GROUP BY State
					  HAVING Summed_Purchases >= 25
					  ORDER BY Summed_Purchases DESC;"

havingCmd <- dbGetQuery(db, sqlCmd8)
print(havingCmd)
```

Question 7: Create a query that counts and distinctly counts (5 points)

The command below displays the number of states and the number of distinct states that are available
within the Customers table. in the column "States", we see a high value because multiples calls in a single
state were made and considered, whereas in the "Distinct_States" column a count was only generated for the first
time that a new state was encountered. This also confirms that purchases were made in all 50 US states.


```{r}
sqlCmd9 <- "SELECT COUNT(State) AS States, COUNT(DISTINCT(State)) AS Distinct_States
            FROM Customers;"

distinctCmd <- dbGetQuery(db, sqlCmd9)
print(distinctCmd)
```

Question 8: Create a query that finds the MIN, MAX, Sum, order by desc (5 points)

```{r}
sqlCmd10 <- "SELECT State, MIN(Purchases_Total) AS Min_Purchase, 
                           MAX(Purchases_Total) AS Max_Purchase, 
                           SUM(Purchases_Total) AS Summed_Purchase
             FROM Customers
             GROUP BY State 
             ORDER BY SUM(Purchases_Total) DESC;"

sumCmd <- dbGetQuery(db, sqlCmd10)
print(sumCmd)
```

Question 9: Create a query that uses Between, and, <, > (5 points)

```{r}
sqlCmd11 <- "SELECT *
           FROM Orders
           WHERE Year_Purchase BETWEEN 2018 AND 2021 
           AND Cost > 10 AND Cost < 300;"

betweenCmd <- dbGetQuery(db, sqlCmd11)
print(betweenCmd)
```

Question 10: Create a query that uses a wildcard, a join, and a group by clause (5 points)

```{r}
sqlCmd12 <- "SELECT State, Purchases_Total, SKU, 
             SUM(Purchases_Total) AS Summed_Purchases
             FROM (SELECT Customers.*, Orders.*
	                 FROM Customers
	                 JOIN Orders on Orders.CustomerID = Customers.CustomerID)
             WHERE State LIKE '%Virginia%'
             GROUP BY State;"

wildcardCmd <- dbGetQuery(db, sqlCmd12)
print(wildcardCmd)
```

Question 11: Create a query that finds the average and uses one of the following AND, OR, NOT (5
points)

```{r}
sqlCmd13 <- "SELECT State, Purchases_Total, AVG(Purchases_Total) AS Average_Purchase
             FROM Customers
             WHERE State = 'Virginia' OR state = 'North Carolina'
             GROUP BY State;"

averageCmd <- dbGetQuery(db, sqlCmd13)
print(averageCmd)
```


Part 2: Complete the following queries using the HIV_info and country_info data. You 
should submit your queries and output in a word document. You will also be 
graded on creativity and complexity. You will need to create the tables and 
import the data before you can complete the queries 


Question 1: Look at both data sets what do you observe? How would you join the data? (5
points)


.mode csv
.separator ','

CREATE TABLE "HIV_Info" (
  "Entity" TEXT,
  "Year" INTEGER,
  "number_of_people_living_with_HIV" INTEGER,
  "deaths<5" INTEGER,
  "deaths>=70" INTEGER,
  "deaths_5-14" INTEGER,
  "deaths_15-49" INTEGER,
  "deaths_50-69" INTEGER,
  "deaths_total" INTEGER,
  "new_cases_of_hiv_infection" INTEGER,
  "number_of_people_infected_with_hiv" INTEGER
);

.import --csv --skip 1 HIV_info.csv HIV_Info
ALTER TABLE HIV_Info RENAME Entity TO Country

CREATE TABLE "Country_Info" (
	"Country"	TEXT,
	"Year" INTEGER,
	"Country_Population" INTEGER,
	"GDP_per_capital" INTEGER,
	"unemployment rate" INTEGER,
	"School_enrollment_rate" INTEGER
);

.import --csv --skip 1 country_info.csv Country_Info

UPDATE Country_Info SET GDP_per_capital = NULL WHERE GDP_per_captial = "Null"
UPDATE Country_Info SET unemployment_rate = NULL WHERE unemployment_rate = "Null"
UPDATE Country_Info SET School_enrollment_rate = NULL WHERE School_enrollment_rate = "Null"


#Will discuss this one with Teena. 
The first point of interest are the NULL values apparent in the country_info data set. A summary of
the NULL values is presented below. Due to the relatively small size of the data set, rows 
containing null values were not removed. Imputation of the null values was also not performed, 
as imputing over 31% of the data set in some columns would cause the artificial values
to have a disproportionate impact on the mean.

The data was joined by a double inner join method. The join was set up during creation of the table, 
where the column name "Entity" in HIV_Info was altered to match the "Country" column in 
Country_Info using the SQLite command ALTER TABLE and RENAME COLUMN to change "Entity" to "Country". 

The double inner join of the data was performed by using both the Country and Year column to create
a surrogate 'primary key' to match up the data in the two tables.

The third point of interest arises with the comparison of the columns "number_of_people_living_with_HIV"
and "number_of_people_infected_with_HIV". In the first column, there is a formatting error where two different
conventions of representing large numbers are mixed up. If this data were presented to an American
audience, the first column value for Bermuda in 2007 should read "92.076", and the second column is a rounded version
of the first column based on this convention. Due to this, the first column will be dropped for the sake of 
clarity and to remove redundancy.

A fourth point of interest is that although the .csv file specifies country data, it includes North America which is 
a continent. North American HIV values in the table HIV_Info seem to be summed values from Bermuda, Canada, and the 
United States per year.

```{r}
db2 <- dbConnect(SQLite(), 
                dbname = "C:/Users/mastl/Documents/DA5020/sqlite-tools-win32-x86-3380500/HIV_Country_Info.db")
#-------------------------------------------------------------------------------------------------------------

HIV_info <- dbGetQuery(db2, "SELECT * FROM HIV_Info")
print(HIV_info)

Country_info <- dbGetQuery(db2, "SELECT * FROM Country_Info")
print(Country_info)

sqlCmd14 <- "SELECT *
             FROM HIV_Info
             INNER JOIN Country_Info ON Country_Info.Country = HIV_Info.Country
             AND Country_Info.Year = HIV_Info.Year;"

#-------------------------------------------------------------------------------------------------------------
#HIV Data Summary
data_explore1 <- dbGetQuery(db2, sqlCmd14)
print(data_explore1)

sqlCmd15 <- 'SELECT AVG("deaths<5"), AVG("deaths>=70"), 
                    AVG("deaths_5-14"), AVG("deaths_15-49"),
                    AVG("deaths_50-69"), AVG("deaths_total"),
                    AVG("new_cases_of_hiv_infection"), AVG("number_of_people_infected_with_HIV")
                    FROM HIV_Info'
                    
sqlCmd16 <- 'SELECT MIN("deaths<5"), MIN("deaths>=70"), 
                    MIN("deaths_5-14"), MIN("deaths_15-49"),
                    MIN("deaths_50-69"), MIN("deaths_total"),
                    MIN("new_cases_of_hiv_infection"), MIN("number_of_people_infected_with_HIV")
                    FROM HIV_Info'
                    
sqlCmd17 <- 'SELECT MAX("deaths<5"), MAX("deaths>=70"), 
                    MAX("deaths_5-14"), MAX("deaths_15-49"),
                    MAX("deaths_50-69"), MAX("deaths_total"),
                    MAX("new_cases_of_hiv_infection"), MAX("number_of_people_infected_with_HIV")
                    FROM HIV_Info'

sqlCmd18 <- 'SELECT (COUNT(*)-COUNT(Country)) AS Country_Null,
	                  (COUNT(*)-COUNT(Year)) AS Year_Null,
	                  (COUNT(*)-COUNT(number_of_people_living_with_HIV)) AS number_of_people_living_with_HIV_Null,
	                  (COUNT(*)-COUNT("deaths<5")) AS "deaths<5_null",
	                  (COUNT(*)-COUNT("deaths>=70")) AS "deaths>=70_Null",
	                  (COUNT(*)-COUNT("deaths_5-14")) AS "deaths_5-14_Null",
	                  (COUNT(*)-COUNT("deaths_15-49")) AS "deaths_15-49_Null",
	                  (COUNT(*)-COUNT("deaths_50-69")) AS "deaths_50-69_Null",
	                  (COUNT(*)-COUNT(deaths_total)) AS deaths_total_Null,
	                  (COUNT(*)-COUNT(new_cases_of_hiv_infection)) AS new_cases_of_hiv_infection_Null
             FROM HIV_Info'

dataAverage <- dbGetQuery(db2, sqlCmd15)
print(dataAverage)

dataMin <- dbGetQuery(db2, sqlCmd16)
print(dataMin)

dataMax <- dbGetQuery(db2, sqlCmd17)
print(dataMax)

nullValues <- dbGetQuery(db2, sqlCmd18)
print(nullValues)

#-------------------------------------------------------------------------------------------------------------
#Country_Info data summary 

sqlCmd19 <- "SELECT AVG(Country_Population), AVG(GDP_per_capital), 
	                  AVG(unemployment_rate), AVG(School_enrollment_rate)
             FROM Country_Info"

sqlCmd20 <- "SELECT MIN(Country_Population), MIN(GDP_per_capital), 
	                  MIN(unemployment_rate), MIN(School_enrollment_rate)
             FROM Country_Info"

sqlCmd21 <- "SELECT MAX(Country_Population), MAX(GDP_per_capital), 
	                  MAX(unemployment_rate), MAX(School_enrollment_rate)
             FROM Country_Info"

sqlCmd22 <- 'SELECT (COUNT(*)-COUNT(Country_Population)) AS Country_Population_Null,
	                  (COUNT(*)-COUNT(GDP_per_capital)) AS GDP_per_capital_Null,
	                  (COUNT(*)-COUNT(unemployment_rate)) AS unemployment_rate_Null,
	                  (COUNT(*)-COUNT(School_enrollment_rate)) AS School_enrollment_rate_Null
             FROM Country_Info'

dataAverage2 <- dbGetQuery(db2, sqlCmd19)
print(dataAverage2)

dataMin2 <- dbGetQuery(db2, sqlCmd20)
print(dataMin2)

dataMax2 <- dbGetQuery(db2, sqlCmd21)
print(dataMax2)

nullValues2 <- dbGetQuery(db2, sqlCmd22)
print(nullValues2)
```

Question 2: Select the Country, Year, new_cases_of_hiv_infection, and
School_enrollment_rate then join the data hiv_info to the country_info table
on Entity/Country and year for only North America (10 points)

```{r}
sqlCmd15 <- "SELECT HIV_Info.Country, HIV_Info.Year, HIV_Info.new_cases_of_hiv_infection, 
             Country_Info.Country_Population, Country_Info.GDP_per_capital, 
             Country_Info.unemployment_rate, Country_Info.School_enrollment_rate
             FROM HIV_Info
             INNER JOIN Country_Info ON Country_Info.Country = HIV_Info.Country 
             AND Country_Info.Year = HIV_Info.Year
             WHERE HIV_Info.Country = 'North America'"

hivCountryJoin <- dbGetQuery(db2, sqlCmd15)
print(hivCountryJoin)
```


Question 3: Select columns Country, Year, Country_Population and get the percentage of
people living with HIV and percentage of deaths from HIV then join the data
hiv_info to the country_info table on Entity/Country and year for only North
America (10 points)

#this will work once we alter the data type of number_of_people_living_with_HIV
```{r}
sqlCmd16 <- "SELECT Country_Info.Country, Country_Info.Year, Country_Info.Country_Population, HIV_Info.*, 
             (HIV_Info.number_of_people_infected_with_hiv/Country_Info.Country_Population *100) AS percentage
             FROM Country_Info
             INNER JOIN HIV_Info ON HIV_Info.Country = Country_Info.Country
             AND HIV_Info.Year = Country_Info.Year"

hivPercentage <- dbGetQuery(db2, sqlCmd16)
print(hivPercentage)
```


Question 4: Select columns Country and get the SUM of the
number_of_people_living_with_HIV divided by Country_Population then join
the data hiv_info to the country_info table on Entity/Country and year not in
North America (10 point)

```{r}
sqlCmd23 <- "SELECT HIV_Info.Country, HIV_Info.Year, CAST(((SUM(REPLACE(HIV_Info.number_of_people_living_with_HIV, ',', '')/1000))) AS                     REAL)/Country_Info.Country_Population
             FROM HIV_Info
             INNER JOIN Country_Info ON Country_Info.Country = HIV_Info.Country 
                        AND Country_Info.Year = HIV_Info.Year
             WHERE HIV_Info.Country IS NOT 'North America'
             GROUP BY HIV_Info.Country, HIV_Info.Year"


countryDivision <- dbGetQuery(db2, sqlCmd23)
print(countryDivision)


```


SELECT HIV_Info.Country, HIV_Info.Year,(SUM(REPLACE(HIV_Info.number_of_people_living_with_HIV, ',', ''))/1000), Country_Info.Country_Population
FROM HIV_Info
INNER JOIN Country_Info ON Country_Info.Country = HIV_Info.Country 
           AND Country_Info.Year = HIV_Info.Year
WHERE HIV_Info.Country IS NOT 'North America'
GROUP BY HIV_Info.Country

Question 5: Produce 5 unique and interesting queries using both datasets. Unique means
that you do not use the same query 5 times and add small parts to it. (15 points,
3 points each)


```{r}
#Query 1: Measure of unemployment variance over years per country

#Query 2:

```






